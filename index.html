<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="chrome=1,IE=edge" />
<title>classroom &middot; WebVR</title>
<!--
<script src="http://www.x3dom.org/download/dev/x3dom.js"></script>
<link rel="stylesheet" href="http://www.x3dom.org/download/dev/x3dom.css">
-->
<link rel="stylesheet" href="css/x3dom.css">
<style>

body {
  width: 100%;
  height: 100%;
  border: 0;
  margin: 0;
  padding: 0;
  color: #fff;
}

#x3dElement {
  width: 100%;
  height: 100%;
  border: 0;
  margin: 0;
  padding: 0;
}

#enterVR {
  background: rgba(0, 0, 0, .35) url("icon-goggles-white.svg") 50% 50% no-repeat;
  background-size: 70% 70%;
  color: #fff;
  height: 50px;
  width: 60px;
  border: none;
  background-color: rgba(120, 120, 120, .35);
  padding: 1px 6px;
  position:absolute;
  top:10px;
  left:10px;
  cursor: pointer;
}

#enterVR:hover {
  background-color: rgba(120, 120, 120, .65);
}

.goggles {
  height: 30px;
  text-align: center;
  color: buttontext;
}

</style>

<script src="js/x3dom.js"></script>

</head>
<body>

<x3d id='x3dElement' showStat='false' showLog='false'>
<scene id='scene'>
  <Environment frustumCulling="false"></Environment>
  <worldInfo
    info='"Created using RenderPark (http://www.cs.kuleuven.ac.be/cwis/research/graphics/RENDERPARK/)"'
    title='Some nice model'></worldInfo>
  <navigationInfo headlight='false' type='"EXAMINE" "WALK"'></navigationInfo>
  <viewpoint id='vpp' def='vp'
    description='ViewPoint 1'
    centerofrotation='3.4625 1.73998 -5.55'
    orientation='0 1 0 2.99229'
    position='4.17102 1.00905 -6.97228'
    znear="0.001" zfar="300"></viewpoint>
  <viewpoint def='AOPT_CAM'
    centerofrotation='3.4625 1.73998 -5.55'
    position='3.4625 1.73998 8.69028'></viewpoint>
  <background DEF='bgnd' skyColor="0 0 0"></background>

  <group id='root' render='false'>
    <group DEF='theScene'>
      <shape DEF='_G_0'>
        <appearance>
          <material diffuseColor='1 1 1'></material>
        </appearance>
        <binaryGeometry DEF='BG_0'
          vertexCount='39268 42234'
          primType='"TRIANGLESTRIP" "TRIANGLES"'
          position='3.5 1.73999583721 -5.62500476837'
          size='7 3.52000808716 11.2500095367'
          index='binGeoClassroom/BG_0_indexBinary.bin'
          coord='binGeoClassroom/BG_0_coordBinary.bin'
          normal='binGeoClassroom/BG_0_normalBinary.bin'
          color='binGeoClassroom/BG_0_colorBinary.bin'>
        </binaryGeometry>
      </shape>
      <shape DEF='_G_1'>
        <appearance>
          <material diffuseColor='1 1 1'></material>
        </appearance>
        <binaryGeometry DEF='BG_1'
          vertexCount='47266 36978'
          primType='"TRIANGLESTRIP" "TRIANGLES"'
          position='3.46249985695 1.7399777174 -5.5'
          size='7.07499980927 3.48003673553 11'
          index='binGeoClassroom/BG_1_indexBinary.bin'
          coord='binGeoClassroom/BG_1_coordBinary.bin'
          normal='binGeoClassroom/BG_1_normalBinary.bin'
          color='binGeoClassroom/BG_1_colorBinary.bin'>
        </binaryGeometry>
      </shape>
      <shape DEF='_G_2'>
        <appearance>
          <material diffuseColor='1 1 1'></material>
        </appearance>
        <binaryGeometry DEF='BG_2' vertexCount='19026 4968'
          primType='"TRIANGLESTRIP" "TRIANGLES"'
          position='3.56500005722 1.73996007442 -5.55000257492'
          size='6.86999988556 3.51999878883 11.4000043869'
          index='binGeoClassroom/BG_2_indexBinary.bin'
          coord='binGeoClassroom/BG_2_coordBinary.bin'
          normal='binGeoClassroom/BG_2_normalBinary.bin'
          color='binGeoClassroom/BG_2_colorBinary.bin'>
        </binaryGeometry>
      </shape>
    </group>
  </group>

  <group id="stereo" render="true">
    <group def='left'>
      <shape>
        <appearance>
          <renderedtexture id="rtLeft" stereoMode="LEFT_EYE" update='ALWAYS'
            dimensions='640 800 4' repeatS='false' repeatT='false'>
            <viewpoint use='vp' containerfield='viewpoint'></viewpoint>
            <background use='bgnd' containerfield='background'></background>
            <group use='theScene' containerfield="scene"></group>
          </renderedtexture>
          <composedshader>
            <field name='tex' type='SFInt32' value='0'></field>
            <shaderpart type='VERTEX'>
            attribute vec3 position;
            attribute vec2 texcoord;

            uniform mat4 modelViewProjectionMatrix;
            varying vec2 fragTexCoord;

            void main()
            {
              vec2 pos = sign(position.xy);
              fragTexCoord = texcoord;

              gl_Position = vec4((pos.x - 1.0) / 2.0, pos.y, 0.0, 1.0);
            }
            </shaderpart>
            <shaderpart def="frag" type='FRAGMENT'>
            #ifdef GL_ES
            precision highp float;
            #endif

            uniform sampler2D tex;
            varying vec2 fragTexCoord;

            void main()
            {
              gl_FragColor = texture2D(tex, fragTexCoord);
            }
            </shaderpart>
          </composedshader>
        </appearance>
        <plane solid="false"></plane>
      </shape>
    </group>

    <group def='right'>
      <shape>
        <appearance>
          <renderedtexture id="rtRight" stereoMode="RIGHT_EYE" update='ALWAYS'
          dimensions='640 800 4' repeatS='false' repeatT='false'>
            <viewpoint use='vp' containerfield='viewpoint'></viewpoint>
            <background use='bgnd' containerfield='background'></background>
            <group use='theScene' containerfield="scene"></group>
          </renderedtexture>
          <composedshader>
            <field name='tex' type='SFInt32' value='0'></field>
            <shaderpart type='VERTEX'>
            attribute vec3 position;
            attribute vec2 texcoord;

            uniform mat4 modelViewProjectionMatrix;
            varying vec2 fragTexCoord;

            void main()
            {
              vec2 pos = sign(position.xy);
              fragTexCoord = texcoord;

              gl_Position = vec4((pos.x + 1.0) / 2.0, pos.y, 0.0, 1.0);
            }
            </shaderpart>
            <shaderpart use="frag" type='FRAGMENT'>
            </shaderpart>
          </composedshader>
        </appearance>
        <plane solid="false"></plane>
      </shape>
    </group>
  </group>

</scene>
</x3d>


<button id="enterVR" onclick="enterVR();"></button>

<script>

var runtime = null;
var rtLeft, rtRight;
var lastW, lastH;

var vrHMD = null;

function init() {
  runtime = document.getElementById('x3dElement').runtime;

  rtLeft = document.getElementById('rtLeft');
  rtRight = document.getElementById('rtRight');

  // TODO: get these from HMD
  lastW = runtime.getWidth();
  lastH = runtime.getHeight();

  var hw = Math.round(lastW / 2);
  rtLeft.setAttribute('dimensions',  hw + ' ' + lastH + ' 4');
  rtRight.setAttribute('dimensions', hw + ' ' + lastH + ' 4');

  var viewpoint = document.getElementById('vpp');

  var i = 0;

  //runtime.enterFrame = enterFrame;

  requestAnimationFrame(enterFrame);

  function enterFrame() {
    if (!vrHMD) {
      window.requestAnimationFrame(enterFrame);
      return;
    } else {
      vrHMD.requestAnimationFrame(enterFrame);
    }

    var state = vrHMD.getPose();

    if (state.orientation !== null) {
      var h = state.orientation;
      var q = new x3dom.fields.Quaternion(h[0], h[1], h[2], h[3]);

      var aa = q.toAxisAngle();
      viewpoint.setAttribute("orientation",
        [aa[0].x, aa[0].y, aa[0].z, aa[1]].join(' '));
    }

    // TODO: add parent container so don't need to reference initialPosition?
    var initialPosition = [4.17102, 1.00905, -6.97228];
    if (state.position !== null) {
      var posi = viewpoint.requestFieldRef('position');
      posi.x = initialPosition[0]+ state.position[0];
      posi.y = initialPosition[1] + state.position[1];
      posi.z = initialPosition[2] + state.position[2];
      viewpoint.releaseFieldRef('position');
    }

    if (vrHMD.isPresenting) {
      vrHMD.submitFrame();
    }

  };

  runtime.exitFrame = function() {
    return; // temp

    var w = +runtime.getWidth() * 2;
    var h = +runtime.getHeight() * 2;

    if (w != lastW || h != lastH) {
      var half = Math.round(w / 2);
      rtLeft.setAttribute('dimensions',  half + ' ' + h + ' 4');
      rtRight.setAttribute('dimensions', half + ' ' + h + ' 4');

      console.log(w + ", " + h);

      lastW = w;
      lastH = h;
    }

    runtime.triggerRedraw();
  };

  // check support
  if (navigator.getVRDisplays) {
    navigator.getVRDisplays().then(vrDisplayCallback);
  } else {
    console.error('No WebVR 1.0 support');
  }

  var enterVRBtn = document.getElementById('enterVR');
  enterVRBtn.addEventListener('click', function(event){

  });

};

function enterVR() {
  if (!vrHMD) {
    console.log('No VR headset attached');
    return;
  }

  var canvas = document.getElementsByTagName("canvas")[0];
  vrHMD.requestPresent( [ { source: canvas } ] );
}

function vrDisplayCallback(vrdisplays) {
  if (vrdisplays.length) {
    vrHMD = vrdisplays[0];
    console.log(vrHMD);
  } else {
    console.log('NO VRDisplay found');
    alert("Didn't find a VR display!");
    return;
  }

  var leftEyeParams, rightEyeParams,
      leftFOV, rightFOV,
      leftTranslation, rightTranslation;

  leftEyeParams = vrHMD.getEyeParameters("left");
  rightEyeParams = vrHMD.getEyeParameters("right");
  console.log(leftEyeParams);
  console.log(rightEyeParams);

  leftFOV = leftEyeParams.fieldOfView;
  rightFOV = rightEyeParams.fieldOfView;
  console.log(leftFOV);
  console.log(rightFOV);

  // TODO: use to updated views
  // -currently using default in x3dom: 0.064 IPD
  leftTranslation = leftEyeParams.offset;
  rightTranslation = rightEyeParams.offset;
  console.log(leftTranslation);
  console.log(rightTranslation);
}

// start
document.onload = init;

</script>
</body>
</html>
