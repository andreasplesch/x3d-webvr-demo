<html>
<head>
    <title>classroom &middot; webvr</title>
    <meta http-equiv='Content-Type' content='text/html;charset=utf-8'/>
    <meta http-equiv="X-UA-Compatible" content="chrome=1,IE=edge" />
    <!--<script src="http://www.x3dom.org/download/dev/x3dom.js"></script>
    <link rel='stylesheet' href='http://www.x3dom.org/download/dev/x3dom.css'>-->
    <script src="js/x3dom.js"></script>
    <link rel="stylesheet" href="css/x3dom.css">
    <style>

    body {
        width: 100%;
        height: 100%;
        border: 0;
        margin: 0;
        padding: 0;
        color: #fff;
    }

    #enterVR {
        background: rgba(0, 0, 0, .35) url("icon-goggles-white.svg") 50% 50% no-repeat;
        background-size: 70% 70%;
        color: #fff;
        height: 50px;
        width: 60px;
        border: none;
        background-color: rgba(120, 120, 120, .35);
        padding: 1px 6px;
        position:absolute;
        top:10px;
        left:10px;
        cursor: pointer;
    }

    #enterVR:hover {
        background-color: rgba(120, 120, 120, .65);
    }

    .goggles {
        height: 30px;
        text-align: center;
        color: buttontext;
    }

    </style>
</head>
<body>



<x3d id='x3dElement' showStat='false' showLog='false' style='width:100%; height:100%; border:0; margin:0; padding:0;'>
<!-- <x3d id='x3dElement' showStat='false' showLog='false' width="800px" height="600px"> -->
    <scene id='scene'>
        <Environment frustumCulling="false"></Environment>
        <worldInfo info='"Created using RenderPark (http://www.cs.kuleuven.ac.be/cwis/research/graphics/RENDERPARK/)"'
                   title='Some nice model'></worldInfo>
        <navigationInfo headlight='false' type='"EXAMINE" "WALK"'></navigationInfo>
        <viewpoint id='vpp' def='vp' description='ViewPoint 1' centerofrotation='3.4625 1.73998 -5.55'
                    orientation='0 1 0 2.99229' position='4.17102 1.00905 -6.97228'
                    znear="0.001" zfar="300"></viewpoint>
        <viewpoint def='AOPT_CAM' centerofrotation='3.4625 1.73998 -5.55' position='3.4625 1.73998 8.69028'></viewpoint>
        <background DEF='bgnd' skyColor="0 0 0"></background>
        <group id='root' render='false'>
            <group DEF='theScene'>
                <shape DEF='_G_0'>
                    <appearance>
                        <material diffuseColor='1 1 1'></material>
                    </appearance>
                    <binaryGeometry DEF='BG_0' vertexCount='39268 42234' primType='"TRIANGLESTRIP" "TRIANGLES"'
                                    position='3.5 1.73999583721 -5.62500476837' size='7 3.52000808716 11.2500095367'
                                    index='binGeoClassroom/BG_0_indexBinary.bin'
                                    coord='binGeoClassroom/BG_0_coordBinary.bin'
                                    normal='binGeoClassroom/BG_0_normalBinary.bin'
                                    color='binGeoClassroom/BG_0_colorBinary.bin'></binaryGeometry>
                </shape>
                <shape DEF='_G_1'>
                    <appearance>
                        <material diffuseColor='1 1 1'></material>
                    </appearance>
                    <binaryGeometry DEF='BG_1' vertexCount='47266 36978' primType='"TRIANGLESTRIP" "TRIANGLES"'
                                    position='3.46249985695 1.7399777174 -5.5' size='7.07499980927 3.48003673553 11'
                                    index='binGeoClassroom/BG_1_indexBinary.bin'
                                    coord='binGeoClassroom/BG_1_coordBinary.bin'
                                    normal='binGeoClassroom/BG_1_normalBinary.bin'
                                    color='binGeoClassroom/BG_1_colorBinary.bin'></binaryGeometry>
                </shape>
                <shape DEF='_G_2'>
                    <appearance>
                        <material diffuseColor='1 1 1'></material>
                    </appearance>
                    <binaryGeometry DEF='BG_2' vertexCount='19026 4968' primType='"TRIANGLESTRIP" "TRIANGLES"'
                                    position='3.56500005722 1.73996007442 -5.55000257492'
                                    size='6.86999988556 3.51999878883 11.4000043869'
                                    index='binGeoClassroom/BG_2_indexBinary.bin'
                                    coord='binGeoClassroom/BG_2_coordBinary.bin'
                                    normal='binGeoClassroom/BG_2_normalBinary.bin'
                                    color='binGeoClassroom/BG_2_colorBinary.bin'></binaryGeometry>
                </shape>
            </group>
        </group>
        <group render="true">
            <group def='left'>
                <shape>
                    <appearance>
                        <renderedtexture id="rtLeft" stereoMode="LEFT_EYE" update='ALWAYS' dimensions='640 800 4' repeatS='false' repeatT='false'>
                            <viewpoint use='vp' containerfield='viewpoint'></viewpoint>
                            <background use='bgnd' containerfield='background'></background>
                            <group use='theScene' containerfield="scene"></group>
                        </renderedtexture>
                        <composedshader>
                            <field name='tex' type='SFInt32' value='0'></field>
                            <shaderpart type='VERTEX'>
                                attribute vec3 position;
                                attribute vec2 texcoord;

                                uniform mat4 modelViewProjectionMatrix;
                                varying vec2 fragTexCoord;

                                void main()
                                {
                                vec2 pos = sign(position.xy);
                                fragTexCoord = texcoord;

                                gl_Position = vec4((pos.x - 1.0) / 2.0, pos.y, 0.0, 1.0);
                                }
                            </shaderpart>
                            <shaderpart def="frag" type='FRAGMENT'>
                                #ifdef GL_ES
                                precision highp float;
                                #endif

                                uniform sampler2D tex;
                                varying vec2 fragTexCoord;

                                void main()
                                {
                                gl_FragColor = texture2D(tex, fragTexCoord);
                                }
                            </shaderpart>
                        </composedshader>
                    </appearance>
                    <plane solid="false"></plane>
                </shape>
            </group>
            <group def='right'>
                <shape>
                    <appearance>
                        <renderedtexture id="rtRight" stereoMode="RIGHT_EYE" update='ALWAYS' dimensions='640 800 4' repeatS='false' repeatT='false'>
                            <viewpoint use='vp' containerfield='viewpoint'></viewpoint>
                            <background use='bgnd' containerfield='background'></background>
                            <group use='theScene' containerfield="scene"></group>
                        </renderedtexture>
                        <composedshader>
                            <field name='tex' type='SFInt32' value='0'></field>
                            <shaderpart type='VERTEX'>
                                attribute vec3 position;
                                attribute vec2 texcoord;

                                uniform mat4 modelViewProjectionMatrix;
                                varying vec2 fragTexCoord;

                                void main()
                                {
                                vec2 pos = sign(position.xy);
                                fragTexCoord = texcoord;

                                gl_Position = vec4((pos.x + 1.0) / 2.0, pos.y, 0.0, 1.0);
                                }
                            </shaderpart>
                            <shaderpart use="frag" type='FRAGMENT'>
                            </shaderpart>
                        </composedshader>
                    </appearance>
                    <plane solid="false"></plane>
                </shape>
            </group>
        </group>
    </scene>
</x3d>


<button id="enterVR" onclick="enterVR();"></button>

<script>
    var runtime = null;
    var rtLeft, rtRight;
    var lastW, lastH;

    var vrHMD = null;

    document.onload = function ()
    {
        runtime = document.getElementById('x3dElement').runtime;
        rtLeft = document.getElementById('rtLeft');
        rtRight = document.getElementById('rtRight');

        lastW = +runtime.getWidth();
        lastH = +runtime.getHeight();

        var hw = Math.round(lastW / 2);
        rtLeft.setAttribute('dimensions',  hw + ' ' + lastH + ' 4');
        rtRight.setAttribute('dimensions', hw + ' ' + lastH + ' 4');

        var viewpoint = document.getElementById('vpp');
        var initDone = false;

        var i = 0;
        var once = false;

        //runtime.enterFrame = enterFrame;

        requestAnimationFrame(enterFrame);

        function enterFrame() {
            if (!vrHMD)
                return;


            var state = vrHMD.getPose();

            if (!initDone) {
                //console.log(state);
            }

            if (state.orientation !== null) {

                var h = state.orientation;
                var q = new x3dom.fields.Quaternion(h[0], h[1], h[2], h[3]);

                var aa = q.toAxisAngle();
                //console.log(aa[0].x + " " + aa[0].y + " " + aa[0].z + " " + aa[1]);

                viewpoint.setAttribute("orientation", aa[0].x + " " + aa[0].y + " " + aa[0].z + " " + aa[1]);

            }

            var initialPosition = [4.17102, 1.00905, -6.97228];
            if (state.position !== null) {

                var posi = viewpoint.requestFieldRef('position');
                posi.x = initialPosition[0]+ state.position[0];
                posi.y = initialPosition[1] + state.position[1];
                posi.z = initialPosition[2] + state.position[2];
                viewpoint.releaseFieldRef('position');

            }

            //console.log('enterframe: ' + i++);
            if (vrHMD.isPresenting) {
                vrHMD.submitFrame();
            }

            vrHMD.requestAnimationFrame(enterFrame);

            if (!once)
                once = true;
        };

        runtime.exitFrame = function ()
        {

            return;
            var w = +runtime.getWidth() * 2;
            var h = +runtime.getHeight() * 2;

            if (w != lastW || h != lastH)
            {
                var half = Math.round(w / 2);
                rtLeft.setAttribute('dimensions',  half + ' ' + h + ' 4');
                rtRight.setAttribute('dimensions', half + ' ' + h + ' 4');

                console.log(w + ", " + h);

                lastW = w;
                lastH = h;
            }

            if (!initDone) {
                initDone = true;
            }

            runtime.triggerRedraw();
        };

    };

    function enterVR()
    {
        if (vrHMD) {

            var canvas = document.getElementsByTagName("canvas")[0];

            vrHMD.requestPresent( [ { source: canvas } ] );

        }
    }

    /* ----------------------------------------------------------- */
    function vrDisplayCallback(vrdisplays) {
        var i;

        // First, find a VRDisplay -- just use the first one we find
        for (i = 0; i < vrdisplays.length; ++i) {
            if (vrdisplays[i] instanceof VRDisplay) {
                vrHMD = vrdisplays[i];
                console.log(vrHMD);
                break;
            }
        }

        if (!vrHMD) {
            alert("Didn't find a VR display!");
            return;
        }

        var leftEyeParams,
            rightEyeParams,
            leftFOV,
            rightFOV,
            leftTranslation,
            rightTranslation;


        leftEyeParams = vrHMD.getEyeParameters("left");
        rightEyeParams = vrHMD.getEyeParameters("right");

        console.log(leftEyeParams);
        console.log(rightEyeParams);

        leftFOV = leftEyeParams.fieldOfView;
        rightFOV = rightEyeParams.fieldOfView;

        console.log(leftFOV);
        console.log(rightFOV);

        leftTranslation = leftEyeParams.offset;
        rightTranslation = rightEyeParams.offset;

        console.log(leftTranslation);
        console.log(rightTranslation);
    }

    if (navigator.getVRDisplays)
        navigator.getVRDisplays().then(vrDisplayCallback);
    else
        console.error('No WebVR 1.0 support');

    // http://webvr.info/
</script>
</body>
</html>
